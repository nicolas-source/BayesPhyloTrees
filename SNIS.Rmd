---
title: "FinalProjectSNIS"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressPackageStartupMessages(library(distr))
library(extraDistr)
```

# SNIS Approach

```{r}
# create a matrix of distances, columns refer to arrangement index and rows refer to a specific node. Each entry in the matrix is the distance b/w the node and the root in that particular arrangement. 

o1 = c(0, 3, 3, 2, 1)
t1 = c(3, 0, 1, 2, 3)
th1 = c(3, 1, 0, 2, 3)
f1 = c(2, 2, 2, 0, 2)
fi1 = c(1, 3, 3, 2, 0)

distance1 = data.frame(o1, t1, th1, f1, fi1)


o2 = c(0, 2, 2, 2, 2)
t2 = c(2, 0, 1, 3, 3)
th2 = c(2, 1, 0, 3, 3)
f2 = c(2, 3, 3, 0, 1)
fi2 = c(2, 3, 3, 1, 0)

distance2 = data.frame(o2, t2, th2, f2, fi2)

orders = data.frame(c(2, 3, 4, 5), c(2, 4, 3, 5), c(3, 4, 2, 5), c(2, 3, 5, 4), c(2, 5, 3, 4), c(3, 5, 2, 4), c(2, 4, 5, 3), c(2, 5, 4, 3), c(5, 4, 2, 3), c(3, 4, 5, 2), c(3, 5, 4, 2), c(4, 5, 3, 2), c(2, 3, 4, 5), c(2, 4, 3, 5), c(2, 5, 3, 4))

```

```{r}

posterior = function(ppl_function, number_of_iterations) {
  numerator = 0.0
  denominator = 0.0
  for (i in 1:number_of_iterations) {
    weight <<- 1.0
    g_i = ppl_function()
    numerator = numerator + weight * g_i
    denominator = denominator + weight
  }
  return(numerator/denominator)
}

# change p function from original SNIS implementation

p <- function(arrangement, rate, msa) {
  
  if(arrangement > 12) {
    
    distance = distance2
    
  } else {
    
    distance = distance1
    
  }
  
  prob = 1
  
  for(i in 2:5) {
    j = 1
    while(j < i) {
      
      length = distance[i, j]
      
      first = msa[orders[i-1, arrangement]]
      
      if(j == 1){
        
        second = msa[1]
        
      } else {
        
        second = msa[orders[j-1, arrangement]]
        
      }

      
      for (k in 1:nchar(first)) {
        
        new_char = substring(first, k, k)
        original_char = substring(second, k, k)
        
        if(new_char == original_char) {
        
        # if char hasn't changed, use 1 - rate
        prob = prob * 1/2 * (1-exp(-2*(1-rate)*length))
        
        } else {
        prob = prob * 1/2 * (1-exp(-2*rate*length))
        }
        
      }
      
      j = j+1
      
    }
    
  }
  
  return(prob)
  
}

Bern = function(probability_to_get_one) {
  DiscreteDistribution(supp = 0:1, prob = 
                         c(1-probability_to_get_one, probability_to_get_one))
}

simulate <- function(distribution) {
  r(distribution)(1) # sample once from the given distribution
}

# Use observe(realization, distribution) for observed random variables
observe = function(arrangement, rate, msa) {
  # `<<-` lets us modify variables that live in the global scope from inside a function
  weight <<- weight * p(arrangement, rate, msa) 
}


```

```{r}
msa = c("11", "10", "00", "01", "11")

tree = function() {
  
  arrangement = as.numeric(rdunif(1, 1, 15))
  rate = simulate(Unif(0, 1))
  observe(arrangement, rate, msa)
  
  return(arrangement) 
}


```

